package com.example.myapplication.data

import androidx.room.*
import com.example.myapplication.model.Films
import kotlinx.coroutines.flow.MutableStateFlow

@Dao
interface DaoFilms {

    @Insert( onConflict = OnConflictStrategy.IGNORE)//проверка на то что бы не было одинаковых фильмов
     fun insert(film: FilmsId)


//    @Query("SELECT * FROM FILMS_TABLE ORDER BY id ASC")//
//    fun readAllData(): List<Films>?

    @Delete
    fun delete(Film: FilmsId)

}
//загрузить функцию  которая будет показывать что стринг

//показываем как мы с ним работаем
//В объекте Dao мы будем описывать методы для работы с базой данных.

//Тут никакие запросы указывать не нужно. Названия методов могут быть любыми. Главное - аннотации.

//@Dao - В Dao интерфейсе описываем метод, который на вход принимает Entity

//@Insert - Аннотация Insert - это простой способ вставить объект в базу данных.

//@Update - Эта аннотация аналогична Insert, но она не вставляет, а обновляет объекты в бд.
//Update ищет в бд запись по ключу. Если не найдет, то ничего не произойдет.
//Если найдет, то обновит все поля, а не только те, которые мы заполнили в Entity объекте.

//@Delete - Методы с аннотацией Delete будут удалять объект.
// В Delete методах мы также можем использовать коллекции и varargs, чтобы удалять несколько объектов сразу.
//Delete ищет в бд запись по ключу.
//Мы можем получить количество удаленных записей. Delete ищет в бд запись по ключу. Для этого необходимо описать метод так, чтобы он возвращал int.

//@Transaction - Аннотация @Transaction позволяет выполнять несколько методов в рамках одной транзакции.

//@Query - В Query прописываем запрос, который должен вернуть данные. А в качестве возвращаемого типа указываем List<Employee>.
//При вызове этого метода, Room сделает запрос в таблицу employee, конвертирует полученные данные в Employee объекты и упакует их в List.
//Запрос, который вы указываете в Query проверяется на правильность синтаксиса во время компиляции. Если в нем будет ошибка, система вам сразу подскажет это.
//В Query можно передавать параметры, чтобы сделать запросы более конкретными. Например, запрос данных по id

//LiveData - Room умеет возвращать данные в LiveData обертке.
//Использование LiveData имеет огромное преимущество перед использование списка или массива.
//Подписавшись на LiveData, вы будете получать свежие данные при их изменении в базе. Т.е. при добавлении новых,
//удалении старых или обновлении текущих данных в таблице employee, Room снова выполнит ваш Query запрос,
//и вы получите в onChanged методе актуальные данные с учетом последних изменений.
//Вам больше не надо самим запрашивать эти данные каждый раз. И все это будет приходить вам в UI поток.